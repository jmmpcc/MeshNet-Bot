services:
  broker:
    image: ghcr.io/jmmpcc/meshnet-bot-broker:latest
    container_name: meshnet-broker
    restart: unless-stopped

    env_file:
      - .env

    entrypoint: ["/usr/local/bin/entrypoint_broker.sh"]

    # Puertos expuestos hacia la red local de la Raspberry
    ports:
      - "${BROKER_PORT_HOST:-8765}:${BROKER_PORT:-8765}"
      - "${BACKLOG_PORT_HOST:-8766}:${BACKLOG_PORT:-8766}"
      - "${WEB_PORT_HOST:-8080}:${WEB_PORT:-8080}"

    # Datos persistentes de bot/broker (backlogs, mapas, auditorías, etc.)
    volumes:
      - ./bot_data:/app/bot_data:rw

    stop_grace_period: 15s


  bot:
    image: ghcr.io/jmmpcc/meshnet-bot-bot:latest
    container_name: meshnet-bot

    depends_on:
      - broker

    restart: on-failure

    env_file:
      - .env

    entrypoint: ["/usr/local/bin/entrypoint_bot.sh"]

    # Comparte red con el broker: BROKER_HOST=127.0.0.1 del .env sigue siendo válido
    network_mode: "service:broker"

    volumes:
      - ./bot_data:/app/bot_data:rw

    stop_grace_period: 10s


  aprs:
    image: ghcr.io/jmmpcc/meshnet-bot-aprs:latest
    container_name: meshnet-aprs

    depends_on:
      - broker

    restart: unless-stopped

    env_file:
      - .env

    entrypoint: ["/usr/local/bin/entrypoint_aprs.sh"]

    # Comparte red con el broker; APRS_CTRL_HOST=127.0.0.1 y BROKER_HOST=127.0.0.1 tienen sentido
    network_mode: "service:broker"

    volumes:
      - ./bot_data:/app/bot_data:rw

    stop_grace_period: 10s
 
  meshnet-bridge-bc:
    image: ghcr.io/jmmpcc/meshnet-bot-bridge-bc:latest
    container_name: meshnet-bridge-bc
    restart: unless-stopped
    env_file:
      - .env-triple-bridge

    # Opción 1 (recomendada en Raspberry): usar red del host
    # network_mode: "host"

    # Opción 2: red bridge (por defecto). En este caso:
    # - si el broker está en el mismo compose: BROKER_CTRL_HOST=broker
    # - si el broker está fuera: BROKER_CTRL_HOST=IP_real
    stop_grace_period: 10s

